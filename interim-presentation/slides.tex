% slides.tex
\documentclass[20pt]{beamer}
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usepackage{cancel}
\usepackage{color}
\usepackage{graphicx}
\usepackage{pdfpages}

\usetheme{default}
\usecolortheme{dove}
\useoutertheme{default}

% Slightly smaller title
\setbeamerfont{frametitle}{size=\large}
\setbeamerfont{verb}{size=\small}

% Font
\renewcommand{\ttdefault}{pcr}

% lst settings
\lstset{
    basicstyle=\ttfamily\small,
    gobble=4,
    keywordstyle=\ttfamily\bfseries,
    language=Haskell
}

\newcommand{\vspaced}{
    \vspace{5mm}
}

\begin{document}

\title{Automatic Detection of Recursion Patterns}
\subtitle{Interim thesis presentation}
\author{Jasper Van der Jeugt}
\date{December 19, 2012}

\begin{frame}[plain]
    \titlepage
\end{frame}

% The omnipresence of foldr
% -------------------------

\begin{frame}{Overview}
    \textbf{The omnipresence of foldr} \\
    Generalising foldr \\
    Towards a single fold \\
    Detection of foldr \\
    Detection: results \\
    Future work \\
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    upper :: String -> String
    upper []       = []
    upper (x : xs) =
      toUpper x : upper xs
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    map :: (a -> b) -> [a] -> [b]
    map _ []       = []
    map f (x : xs) = f x : xs
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    upper :: String -> String
    upper = map toUpper
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    evens :: [Int] -> [Int]
    evens []       = []
    evens (x : xs)
      | even x     = x : evens xs
      | otherwise  = evens xs
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    filter
     :: (a -> Bool) -> [a] -> [a]
    filter _ []   = []
    filter p (x : xs)
      | p x       =
          x : filter p xs
      | otherwise = filter p xs
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    evens :: [Int] -> [Int]
    evens = filter even
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    sum :: [Int] -> Int
    sum []       = 0
    sum (x : xs) = x + sum xs
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    foldr
      :: (a -> b -> b)
      -> b -> [a] -> b
    foldr _ z []       = z
    foldr f z (x : xs) =
      f x (foldr f z xs)
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    sum :: [Int] -> Int
    sum = foldr (+) 0
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    map :: (a -> b) -> [a] -> [b]
    map f = foldr ((:) . f) []
    \end{lstlisting}

    \begin{lstlisting}
    filter
      :: (a -> Bool) -> [a] -> [a]
    filter p = foldr
      (\x l -> if p x
        then x : l
        else l)
      []
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    head :: [a] -> a
    head (x : _) = x
    head []      =
      error "empty list"
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    head :: [a] -> a
    head = foldr const
      (error "empty list")
    \end{lstlisting}
\end{frame}

% Generalising foldr
% ------------------

\begin{frame}{Overview}
    The omnipresence of foldr \\
    \textbf{Generalising foldr} \\
    Towards a single fold \\
    Detection of foldr \\
    Detection: results \\
    Future work \\
\end{frame}

\begin{frame}[fragile]{Generalising foldr}
    \begin{lstlisting}
    data [a]     foldr
      = a : [a]    :: (a -> b -> b)
      | []         -> b
                   -> [a] -> b
    \end{lstlisting}

    \begin{lstlisting}
    foldr (+) 0
      (1 : 2 : 3 : []) =
        1 + 2 + 3 + 0
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Generalising foldr}
    \begin{lstlisting}
    data Tree a
      = Branch a (Tree a) (Tree a)
      | Empty

    foldTree
      :: (a -> b -> b)
      -> b
      -> Tree a -> b
    \end{lstlisting}
\end{frame}

\begin{frame}{Generalising foldr}
    \texttt{foldFoo} can be automatically generated for any datatype
    \texttt{Foo} \\
    \vspaced
    The \emph{universal property of foldr} tells us that all other
    implementations are an isomorphism of this version
\end{frame}

\begin{frame}[fragile]{Generalising foldr}
    A proof-of-concept TemplateHaskell implementation is available: \\
    \vspaced
    \begin{lstlisting}
    {-# LANGUAGE
      TemplateHaskell #-}

    $(deriveFold ''Tree)
    \end{lstlisting}
\end{frame}

% Towards a single fold
% ---------------------

\begin{frame}{Overview}
    The omnipresence of foldr \\
    Generalising foldr \\
    \textbf{Towards a single fold} \\
    Detection of foldr \\
    Detection: results \\
    Future work \\
\end{frame}

\begin{frame}[fragile]{Towards a single fold}
    \begin{lstlisting}
    data ListPF a t
      = NilPF
      | ConsPF a t

    instance Functor (ListPF a)
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Towards a single fold}
    \begin{lstlisting}
    toPF :: [a] -> ListPF a [a]
    toPF []       = NilPF
    toPF (x : xs) = ConsPF x xs

    fromPF :: ListPF a [a] -> [a]
    fromPF NilPF         = []
    fromPF (ConsPF x xs) = x : xs
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Towards a single fold}
    \begin{lstlisting}
    class Functor (PF t) =>
        Fold t where
      type PF t :: * -> *

      toPF   :: t -> PF t t
      fromPF :: PF t t -> t
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Towards a single fold}
    \begin{lstlisting}
    fold
      :: Fold t
      => (PF t a -> a) -> t -> a
    fold f =
      f . fmap (fold f) . toPF
    \end{lstlisting}
\end{frame}

% Detection of foldr
% ------------------

\begin{frame}{Overview}
    The omnipresence of foldr \\
    Generalising foldr \\
    Towards a single fold \\
    \textbf{Detection of foldr} \\
    Detection: results \\
    Future work \\
\end{frame}

\begin{frame}{Detection of foldr}
    Detect folds in Haskell code? \\
    Or, detect folds in (GHC) core?
\end{frame}

\begin{frame}[fragile]{Detection of foldr}
    \textbf{GHC core} \\
    \vspaced
    \begin{lstlisting}
    data Expr b
      = Var Id
      | Lit Literal
      | App (Expr b) (Arg b)
      | Lam b (Expr b)
      ...
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Detection of foldr}
    \textbf{Advantages of GHC core} \\
    \vspaced
    Simpler expression type \\
    Multiple passes \\
    Type information \\
\end{frame}

\begin{frame}[fragile]{Detection of foldr}
    \textbf{Disadvantages of GHC core} \\
    \vspaced
    Less useful for refactoring
\end{frame}

\begin{frame}[fragile]{Detection of foldr}
    \begin{lstlisting}
    sum :: [Int] -> Int
    sum []       = 0
    sum (x : xs) = x + sum xs
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Detection of foldr}
    \begin{lstlisting}
    sum :: [Int] -> Int
    sum ls = case ls of
      (:) x xs -> x + sum xs
      []       -> 0
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Detection of foldr}
    \begin{lstlisting}
    sum :: [Int] -> Int
    sum ls = case ls of
      -- Two subterms, one recursive
      (:) x xs ->
        (\t1 t2 -> t1 + t2)
        x
        (sum xs)
      -- No subterms
      []       -> 0
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Detection of foldr}
    \begin{lstlisting}
    sum :: [Int] -> Int
    sum ls = foldr
      (\t1 t2 -> t1 + t2)
      0
      ls
    \end{lstlisting}
\end{frame}

% Detection: results
% ------------------

\begin{frame}{Overview}
    The omnipresence of foldr \\
    Generalising foldr \\
    Towards a single fold \\
    Detection of foldr \\
    \textbf{Detection: results} \\
    Future work \\
\end{frame}

\begin{frame}{Detection: results}
    \textbf{Categories:} \\
    \vspaced
    \textbf{Head fold:} fold without recursion \\
    \textbf{List fold:} proper fold over a list \\
    \textbf{Data fold:} proper fold over another datatype \\
\end{frame}

\begin{frame}[fragile]{Detection: results}
    \begin{tabular}{l|rrr}
                            & \textbf{Head} & \textbf{Data} & \textbf{List} \\
        \hline
        \textbf{hlint}      &           248 &            25 &            17 \\
        \textbf{parsec}     &           150 &             0 &             6 \\
        \textbf{containers} &           311 &            75 &             7 \\
        \textbf{pandoc}     &          1012 &             1 &            35 \\
        \textbf{cabal}      &          1701 &            30 &            43 \\
    \end{tabular}
\end{frame}

% Future work
% -----------

\begin{frame}{Overview}
    The omnipresence of foldr \\
    Generalising foldr \\
    Towards a single fold \\
    Detection of foldr \\
    Detection: results \\
    \textbf{Future work} \\
\end{frame}

\begin{frame}{Future work}
    Mutually recursive datatypes \& folds \\
    Generic programming \\
    Formal analysis \\
    Optimizations \\
\end{frame}

% Questions?
% ----------

\begin{frame}{}
    \begin{center}
    \center\huge{Questions?}
    \end{center}
\end{frame}

\end{document}
