% slides.tex
\documentclass[20pt]{beamer}
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usepackage{cancel}
\usepackage{color}
\usepackage{graphicx}
\usepackage{pdfpages}

\usetheme{default}
\usecolortheme{dove}
\useoutertheme{default}

% Slightly smaller title
\setbeamerfont{frametitle}{size=\large}
\setbeamerfont{verb}{size=\small}

% Font
\renewcommand{\ttdefault}{pcr}

% lst settings
\lstset{
    basicstyle=\ttfamily\small,
    gobble=4,
    keywordstyle=\ttfamily\bfseries,
    language=Haskell
}

\newcommand{\vspaced}{
    \vspace{5mm}
}

\begin{document}

\title{Automatic Detection of Recursion Patterns}
\subtitle{Interim thesis presentation}
\author{Jasper Van der Jeugt}
\date{December 19, 2012}

\begin{frame}[plain]
    \titlepage
\end{frame}

% The omnipresence of foldr
% -------------------------

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    upper :: String -> String
    upper []       = []
    upper (x : xs) =
      toUpper x : upper xs
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    map :: (a -> b) -> [a] -> [b]
    map _ []       = []
    map f (x : xs) = f x : xs
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    upper :: String -> String
    upper = map toUpper
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    evens :: [Int] -> [Int]
    evens []       = []
    evens (x : xs)
      | even x     = x : evens xs
      | otherwise  = evens xs
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    filter
     :: (a -> Bool) -> [a] -> [a]
    filter _ []   = []
    filter p (x : xs)
      | p x       =
          x : filter p xs
      | otherwise = filter p xs
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    evens :: [Int] -> [Int]
    evens = filter even
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    sum :: [Int] -> Int
    sum []       = 0
    sum (x : xs) = x + sum xs
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    foldr
      :: (a -> b -> b)
      -> b -> [a] -> b
    foldr _ z []       = z
    foldr f z (x : xs) =
      f x (foldr f z xs)
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    sum :: [Int] -> Int
    sum = foldr (+) 0
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    map :: (a -> b) -> [a] -> [b]
    map f = foldr ((:) . f) []
    \end{lstlisting}

    \begin{lstlisting}
    filter
      :: (a -> Bool) -> [a] -> [a]
    filter p = foldr
      (\x l -> if p x
        then x : l
        else l)
      []
    \end{lstlisting}
\end{frame}

\end{document}
