% slides.tex
\documentclass[20pt]{beamer}
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usepackage{cancel}
\usepackage{color}
\usepackage{graphicx}
\usepackage{pdfpages}

\usetheme{default}
\usecolortheme{dove}
\useoutertheme{default}

% Slightly smaller title
\setbeamerfont{frametitle}{size=\large}
\setbeamerfont{verb}{size=\small}

% Font
\renewcommand{\ttdefault}{pcr}

% lst settings
\lstset{
    basicstyle=\ttfamily\small,
    gobble=4,
    keywordstyle=\ttfamily\bfseries,
    language=Haskell
}

\newcommand{\vspaced}{
    \vspace{5mm}
}

\begin{document}

\title{Automatic Detection of Recursion Patterns}
\subtitle{Interim thesis presentation}
\author{Jasper Van der Jeugt}
\date{December 19, 2012}

\begin{frame}[plain]
    \titlepage
\end{frame}

% The omnipresence of foldr
% -------------------------

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    upper :: String -> String
    upper []       = []
    upper (x : xs) =
      toUpper x : upper xs
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    map :: (a -> b) -> [a] -> [b]
    map _ []       = []
    map f (x : xs) = f x : xs
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    upper :: String -> String
    upper = map toUpper
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    evens :: [Int] -> [Int]
    evens []       = []
    evens (x : xs)
      | even x     = x : evens xs
      | otherwise  = evens xs
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    filter
     :: (a -> Bool) -> [a] -> [a]
    filter _ []   = []
    filter p (x : xs)
      | p x       =
          x : filter p xs
      | otherwise = filter p xs
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    evens :: [Int] -> [Int]
    evens = filter even
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    sum :: [Int] -> Int
    sum []       = 0
    sum (x : xs) = x + sum xs
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    foldr
      :: (a -> b -> b)
      -> b -> [a] -> b
    foldr _ z []       = z
    foldr f z (x : xs) =
      f x (foldr f z xs)
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    sum :: [Int] -> Int
    sum = foldr (+) 0
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    map :: (a -> b) -> [a] -> [b]
    map f = foldr ((:) . f) []
    \end{lstlisting}

    \begin{lstlisting}
    filter
      :: (a -> Bool) -> [a] -> [a]
    filter p = foldr
      (\x l -> if p x
        then x : l
        else l)
      []
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    head :: [a] -> a
    head (x : _) = x
    head []      =
      error "empty list"
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The omnipresence of foldr}
    \begin{lstlisting}
    head :: [a] -> a
    head = foldr const
      (error "empty list")
    \end{lstlisting}
\end{frame}

% Generalising foldr
% ------------------

\begin{frame}[fragile]{Generalising foldr}
    \begin{lstlisting}
    data [a]     foldr
      = a : [a]    :: (a -> b -> b)
      | []         -> b
                   -> [a] -> b
    \end{lstlisting}

    \begin{lstlisting}
    foldr (+) 0
      (1 : 2 : 3 : []) =
        1 + 2 + 3 + 0
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Generalising foldr}
    \begin{lstlisting}
    data Tree a
      = Branch a (Tree a) (Tree a)
      | Empty

    foldTree
      :: (a -> b -> b)
      -> b
      -> Tree a -> b
    \end{lstlisting}
\end{frame}

\begin{frame}{Generalising foldr}
    \texttt{foldFoo} can be automatically generated for any datatype
    \texttt{Foo} \\
    \vspaced
    The \emph{universal property of foldr} tells us that all other
    implementations are an isomorphism of this version
\end{frame}

\begin{frame}[fragile]{Generalising foldr}
    A proof-of-concept TemplateHaskell implementation is available: \\
    \vspaced
    \begin{lstlisting}
    {-# LANGUAGE
      TemplateHaskell #-}

    $(deriveFold ''Tree)
    \end{lstlisting}
\end{frame}

\end{document}
